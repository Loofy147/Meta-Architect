from dataclasses import dataclass
from typing import List
from lma.cmcg import CrossModalCausalGraph
from lma.telemetry import TelemetrySnapshot

@dataclass
class Hypothesis:
    """Causal hypothesis generated by HGE."""
    id: str
    description: str
    antecedent: str  # Condition
    consequent: str  # Expected effect
    confidence: float
    supporting_evidence: List[str]
    testable_prediction: str


class HypothesisGenerationEngine:
    """Generate causal hypotheses from telemetry patterns."""

    def __init__(self, cmcg: CrossModalCausalGraph):
        self.cmcg = cmcg
        self.hypothesis_counter = 0
        self.active_hypotheses: List[Hypothesis] = []

    def generate_from_snapshot(self, snapshot: TelemetrySnapshot) -> List[Hypothesis]:
        """Generate hypotheses from current telemetry."""
        hypotheses = []

        # Pattern 1: High kappa + Low gradient → Rank collapse causing vanishing gradient
        for key, kappa in snapshot.condition_numbers.items():
            if kappa > 50:
                coord = key.split('_')[0]
                grad = snapshot.gradient_norms.get(coord, 1.0)
                if grad < 1e-4:
                    h = Hypothesis(
                        id=f"H-{self.hypothesis_counter}",
                        description="Rank collapse causing vanishing gradient",
                        antecedent=f"κ({key}) > 50 AND ||∇|| < 1e-4",
                        consequent="Vanishing gradient in affected head",
                        confidence=0.85,
                        supporting_evidence=[f"κ={kappa:.2f}", f"||∇||={grad:.2e}"],
                        testable_prediction="Reset projections will restore gradient flow"
                    )
                    hypotheses.append(h)
                    self.hypothesis_counter += 1

        # Pattern 2: Entropy decline + T_mix increase → Specialization-complexity coupling
        for coord, entropy in snapshot.attention_entropy.items():
            deriv = snapshot.entropy_derivatives.get(coord, 0)
            if deriv < -0.01 and snapshot.t_mix > 45:
                h = Hypothesis(
                    id=f"H-{self.hypothesis_counter}",
                    description="Entropy decline driving GNN complexity",
                    antecedent=f"ΔH({coord})/Δt < -0.01 AND T_mix > 45µs",
                    consequent="Increased mixing computational load",
                    confidence=0.73,
                    supporting_evidence=[f"H={entropy:.3f}", f"ΔH={deriv:.4f}",
                                       f"T_mix={snapshot.t_mix:.1f}µs"],
                    testable_prediction="Entropy regularization will reduce T_mix"
                )
                hypotheses.append(h)
                self.hypothesis_counter += 1

        self.active_hypotheses.extend(hypotheses)
        return hypotheses
